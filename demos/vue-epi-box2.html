<head>
  <link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" />
</head>

<body>
  <div id="app" class="container-fluid">
    <h1>Model Test Lab</h1>
    <div class="row">
      <div id="timeplot" style="height:640px; margin:0px; padding:0px;" class="col-lg-4"></div>
      <div id="display" style="height:640px; margin:0px; padding:0px;" class="col-lg-8"></div>
    </div>
    <experiment-log :log="log" :improvement="improvement"></experiment-log>
    <div class="col-lg-6">
      <div class="btn btn-success btn-lg" @click="launch()">Launch Full</div>
      <experiment-form :experiment="experiment"></experiment-form>
      <report-form :report="report"></report-form>
      <evolution-form :evolution="evolution"></evolution-form>
      <pathogen-form :pathogen="pathogen"></pathogen-form>
    </div>
    <div class="col-lg-6">
      <div class="btn btn-primary btn-lg" @click="visualize()">Visualize Run</div>
      <environment-form :environment="environment"></environment-form>
      <agents-form :agents="agentGrp" v-for="(agentGrp, grp) in agents"></agents-form>
      <components-form :comp="component" :params="agents[component.agents].params" :groups="Object.keys(agents)" v-for="component in components"></components-form>
    </div>
  </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/vue/2.2.5/vue.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/4.7.3/d3.js"></script>
  <script src="../node_modules/plotly.js/dist/plotly-basic.min.js"></script>
  <script src="./libs/jStat.min.js"></script>
  <script src="../node_modules/three/build/three.min.js"></script>
  <script src="actions.js"></script>
  <script src="../qepikit.js"></script>
  <script src="./epi-vue-components.js"></script>
  <script>
    let pathogen;
    let boundaries = {
      people: {
        left: 1,
        right: 600 - 1,
        top: 600 - 1,
        bottom: 1
      }
    };
    let agents;
    let exp;
    let cfg;
    let env = new QEpiKit.Environment();
    let infectedAtStart = 8;
    let random;
    let scene;
    let raycaster = new THREE.Raycaster();
    let camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);
    let renderer = new THREE.WebGLRenderer({
      alpha: true
    });

    let app = new Vue({
          el: '#app',
          data: {
            log: [],
            improvement: -1,
            experiment: {
              seed: 12345,
              rng: new QEpiKit.RNGBurtle(this.seed),
              iterations: 5,
              type: 'evolution',
              size: 10
            },
            evolution: {
              params: [{
                level: 'agents',
                group: 'people',
                name: 'contactAttempts',
                range: [1, 100]
              }, {
                level: 'environment',
                group: 'pathogen',
                name: 'shedRate',
                range: [100, 1000]
              }],
              target: {
                freqs: {
                  infectious: 44
                }
              }
            },
            environment: {
              step: 0.001,
              until: 1,
              type: 'continuous',
              bounds: [500, 400],
              params: {}
            },
            report: {
              sums: ['pathogenLoad', 'contactAttempts'],
              means: ['pathogenLoad', 'contactAttempts','BMI'],
              freqs: ['immune', 'succeptible', 'exposed', 'infectious','diet']
            },
            pathogen: {
              name: 'influenza',
              personToPerson: true,
              N50: 9.45e5,
              optParam: 5.81e-1,
              bestFitModel: 'beta-Poisson',
              decayRate: 4.5,
              recoveryTime: 6,
              shedRate: 700,
              mutationTime: 36,
              'beta-Poisson': function(dose) {
                let response = 1 - Math.pow((1 + (dose / this.N50) * (Math.pow(2, (1 / this.optParam)) - 1)), (-this.optParam));
                return response;
              },
              'exponential': function(dose) {
                let response = 1 - Math.exp(-this.optParam * dose);
                return response;
              }
            },
            agents: {
              'people': {
                name: 'people',
                count: 1000,
                boundaries: {
                  left: 1,
                  right: 500 - 1,
                  top: 500 - 1,
                  bottom: 1
                },
                params: {
                  'movePerDay': {
                    assign: () => {
                      return random.normal(3000, 1000);
                    }
                  },
                  'age': {
                    assign: () => {
                      return random.randRange(18, 65);
                    }
                  },
                  'sex': {
                    assign: () => {
                      return random.pick(['male', 'female']);
                    }
                  },
                  'calAbsorbPct': {
                    assign: () => {
                      return random.normal(0.6, 0.1);
                    }
                  },
                  'dailyActivitiesPct': {
                    assign: 1.326,
                  },
                  'group': {
                    assign: () => {
                      return random.pick(['control', 'diet', 'exercise', 'dietExercise']);
                    }
                  },
                  'moveRate': {
                    assign: () => {
                      return Math.max(0.01, random.normal(2, 0.5));
                    } //miles per day
                  },
                  'contactAttempts': {
                    assign: 20
                  },
                  'newAttempt': {
                    assign: 0
                  },
                  'madeAttempts': {
                    assign: 0
                  },
                  'pathogenLoad': {
                    assign: 0
                  },
                  'responseProb': {
                    assign: 0
                  },
                  'timeInfectious': {
                    assign: 0
                  },
                  'timeRecovered': {
                    assign: 0
                  },
                  'infected': {
                    assign: false
                  },
                  'percentImmune': {
                    assign: 0.4
                  },
                  'percentInfected': {
                    assign: 0.1
                  },
                  'states': {
                    assign: function() {
                      let r = random.random();
                      let state = 'succeptible'
                      if (r < 0.2) {
                        state = 'immune';
                      }
                      if (r >= 0.2 && r < 0.22) {
                        state = 'infectious';
                      }
                      return {
                        'illness': state
                      };
                    }
                  },
                  'assigned': {
                    assign: (person) => {
                      switch (person.group) {
                        case 'control':
                          person.exerciseAmount = random.randRange(0, 120);
                          person.exerciseMETS = random.randRange(2, 3);
                          person.calRawIntake = random.randRange(1200, 4000);
                          break;
                        case 'diet':
                          person.exerciseAmount = random.randRange(0, 120);
                          person.exerciseMETS = random.randRange(2, 3);
                          person.calRawIntake = random.randRange(1200, 2500);
                          break;
                        case 'exercise':
                          person.exerciseAmount = random.randRange(30, 120);
                          person.exerciseMETS = random.randRange(3, 6);
                          person.calRawIntake = random.randRange(1200, 4000);
                          break;
                        case 'dietExercise':
                          person.exerciseAmount = random.randRange(30, 120);
                          person.exerciseMETS = random.randRange(3, 6);
                          person.calRawIntake = random.randRange(1200, 2500);
                          break;
                        default:
                          break;
                          return true;
                      }
                    }
                  },
                    'mass': {
                      assign: (person) => {
                        if (person.sex === 'male') {
                          person.mass = random.normal(64, 10);
                          person.fatMass = person.mass * random.randRange(0.1, 0.5);
                          person.fatFreeMass = 13.8 * Math.log(person.fatMass / 0.29);
                        } else {
                          person.mass = random.normal(54, 8);
                          person.fatMass = person.mass * random.randRange(0.15, 0.55);
                          person.fatFreeMass = 10.4 * Math.log(person.fatMass / 0.29);
                        }
                      }
                    },
                    'height': {
                      assign: (person) => {
                        if (person.sex === 'male') {
                          person.height = random.normal(1.77, 0.2);
                        } else {
                          person.height = random.normal(1.62, 0.2);
                        }
                        person.BMI = QActions.calcBMI(0, person);
                        person.BMR = QActions.mifflinStJeor(0, person);
                      }
                    }
                  }
                }
              },
              components: [{
                name: 'SEIR',
                type: 'state-machine',
                agents: 'people',
                states: {
                  'immune': 'immune',
                  'succeptible': 'succeptible',
                  'exposed': 'exposed',
                  'infectious': 'infectious',
                  'removed': 'removed'
                },
                conditions: {
                  'exposure': {
                    key: 'pathogenLoad',
                    value: 0,
                    check: 'gt'
                  },
                  'infection': {
                    key: 'infected',
                    value: true,
                    check: 'equalTo'
                  },
                  'recovery': {
                    key: 'timeInfectious',
                    value: 5, //pathogen.recoveryTime,
                    check: 'gt'
                  },
                  'resucceptible': {
                    key: 'timeRecovered',
                    value: 4, //pathogen.mutationTime,
                    check: 'gt'
                  }
                },
                transitions: [{
                  name: 'exposure',
                  from: 'succeptible',
                  to: 'exposed'
                }, {
                  name: 'infection',
                  from: 'exposed',
                  to: 'infectious'
                }, {
                  name: 'recovery',
                  from: 'infectious',
                  to: 'removed'
                }, {
                  name: 'resucceptible',
                  from: 'removed',
                  to: 'succeptible'
                }]
              }, {
                name: 'Movement',
                type: 'every-step',
                agents: 'people',
                action: QActions.moveWithin
              }, {
                name: 'Metabolism',
                type: 'every-step',
                agents: 'people',
                action: QActions.metabolism
              }]
            },
            methods: {
              compile: function() {
                cfg = {};
                cfg.experiment = this.experiment;
                cfg.environment = this.environment;
                cfg.evolution = this.evolution;
                cfg.environment.params.pathogen = this.pathogen;
                cfg.agents = this.agents;
                cfg.report = this.report;
                cfg.components = [];
                this.components.forEach((comp, i) => {
                  if (comp.type === 'state-machine') {
                    let c = JSON.parse(JSON.stringify(comp));
                    for (let state in comp.states) {
                      c.states[state] = QActions[comp.states[state]];
                    }
                    for (let cond in comp.conditions) {
                      c.conditions[cond].check = QEpiKit[comp.conditions[cond].check];
                    }
                    cfg.components[i] = c;
                  } else {
                    cfg.components[i] = Vue.util.extend({}, comp);
                  }
                })
                random = cfg.experiment.rng;
                pathogen = this.environment.params.pathogen;
              },
              launch: function() {
                this.compile();
                exp = new QEpiKit.Evolutionary(env, cfg);
                exp.start(cfg.experiment.iterations, cfg.environment.step, cfg.environment.until);
                this.improvement = exp.improvement;
                this.log = exp.experimentLog;
              },
              visualize: function() {
                //live update
                this.compile();
                let bounds = cfg.environment.bounds;
                camera.position.z = Math.max(bounds[0], bounds[1]) * 0.5;
                camera.position.x = bounds[0] * 0.5;
                camera.position.y = bounds[1] * 0.5;
                camera.rotation.x = 8 * Math.PI / 180;
                document.querySelector('#display').innerHTML = '';
                document.querySelector('#display').appendChild(renderer.domElement);
                renderer.setSize(1280, 640);
                renderer.setClearColor(0xffffff, 0);

                exp = new QEpiKit.Experiment(env, cfg);
                scene = new THREE.Scene();
                exp.prep(null, cfg)
                env = exp.environment;
                env.init();
                render();
              }
            }
          });

        function freqs() {
          let freqs = {};
          env.agents.forEach((d) => {
            exp.setup.report.freqs.forEach((f) => {
              if (!isNaN(d[f]) && typeof d[f] != 'undefined') {
                freqs[f] = freqs[f] == undefined ? d[f] : d[f] + freqs[f];
              }
            })
          })
          return freqs;
        }

        function format(history, freq, time) {
          let i = 0;
          for (let f in freq) {
            if (!(f in history)) {
              let color = '#' + Math.floor(Math.random() * 16e6).toString(16);
              switch (f) {
                case 'succeptible':
                  color = '#00ff00';
                  break;
                case 'infectious':
                  color = '#ff0000';
                  break;
                case 'immune':
                  color = '#4455ff';
                  break;
                case 'exposed':
                  color = '#ff00ff';
                  break;
                default:
                  break;
              }
              history[f] = {
                x: [],
                y: [],
                name: f,
                mode: 'lines',
                type: 'scatter',
                line: {
                  color: color
                }
              };
            }
            history[f].y.push(freq[f])
            history[f].x.push(time);
          }
          return Object.values(history);
        }

        let plotset = {};

        function render() {
          cfg = Vue.util.extend({}, cfg);
          if (env.time <= cfg.environment.until) {
            //debugger;
            requestAnimationFrame(render);
            env.update(cfg.environment.step);
            env.time += cfg.environment.step;
            if (env.time.toFixed(3) % 0.05 === 0) {
              let freq = freqs();
              let plottable = format(plotset, freq, env.time);
              Plotly.newPlot('timeplot', plottable);
            }
            renderer.render(scene, camera);
          } else {
            let freq = freqs();
            let plottable = format(plotset, freq, env.time);
            Plotly.newPlot('timeplot', plottable);
            plotset = {};
            console.log('done', freq, env);
            let rep = exp.report(0, cfg);
            app._data.log = [rep];
          }
        }
  </script>

</body>
