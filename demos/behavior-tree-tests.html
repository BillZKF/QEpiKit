<html>

<head>
	<link href="style.css" rel="stylesheet"></link>
	<link href="libs/wyard-style.css" rel="stylesheet"></link>
</head>

<body>
	<div class="bh-ctrl" id="control-panel">
		<h1>Behavior Tree Tests</h1>
		<form name="newNode" id="add-node">
			<div class="form-group">
				<label for="node-id">Node ID</label>
				<input id="node-id" name="id" class="form-control"></input>
			</div>
			<div class="form-group">
				<label for="node-type">Node Type</label>
				<select id="node-type" name="type" class="form-control">
					<option>root</option>
					<option>selector</option>
					<option>sequence</option>
					<option>parallel</option>
					<option>condition</option>
					<option>action</option>
				</select>
			</div>
			<div class="form-group">
				<label for="node-parent">Child Of</label>
				<select id="node-parent" name="parent" class="form-control" multiple=true>
					<option value="null">none</option>
				</select>
			</div>
			<label for="conds">Condition</label>
			<div id="conds"></div>
			<label for="acts">Action</label>
			<div id="acts"></div>
			<div class="btn btn-primary" onclick="addNode()">Add Node</div>
			<div class="form-group">
				<label for="node-cond">New Condition</label>
				<input id="node-cond-name" name="condition[name]" class="form-control"></input>
				<select id="node-cond-prop" name="condition[key]" class="form-control">
				</select>
				<select id="node-cond-op" name="condition[check]" class="form-control">
					<option value="equalTo">Equals</option>
					<option value="notEqualTo">Does not Equal</option>
					<option value="gt">Less Than</option>
					<option value="gtEq">Less Than or Equal</option>
					<option value="lt">Greater Than</option>
					<option value="ltEq">Greater Than or Equal</option>
				</select>
				<input id="node-cond-value" name="condition[value]" class="form-control"></input>
				<div id="new-cond" class="btn btn-primary">Add Condition</div>
			</div>
			<div class="form-group">
				<label for="node-cond">New Action</label>
				<input id="node-act-name" placeholder="action name"name="act[name]" class="form-control"></input>
				<select id="act-key" name="act[key]" class="form-control">
				</select>
				<input id="node-cond-value" name="act[func]" class="form-control" placeholder="use math.js"></input>
				<div class="btn btn-primary">Add Action</div>
			</div>


		</form>
	</div>
	<div id="diagram"></div>
	<div id="p1"></div>
	<link data-require="bootstrap-css@*" data-semver="3.2.0" rel="stylesheet" href="../bower_components/bootstrap/dist/css/bootstrap.min.css" />
	<script data-require="jquery@*" data-semver="2.1.1" src="../bower_components/jquery/dist/jquery.min.js"></script>
	<script src="../bower_components/d3/d3.min.js"></script>
	<script src="../bower_components/chance/chance.js"></script>
	<script src="libs/jquery_wyard.js"></script>
	<script src="../dist/behaviorTree.js"></script>
	<script src="../dist/utils.js"></script>
	<script src="bh-weight-gain-ex.js"></script>
	<script>
		var mouseDown = false;
		var t = 0;
		var summary;
		var init = function() {
			var playBtn = document.createElement("div");
			playBtn.setAttribute("class", "btn btn-default");
			playBtn.setAttribute("onclick", "runBHTree()");
			playBtn.innerHTML = "Run Tree";
			render("diagram");

			$("#diagram").on("mousedown", function() {
				mouseDown = true;
			});
			$("#diagram").on("mouseup", function() {
				mouseDown = false;
			});
			$("#new-cond").on('click', function() {
				addCondition(conditions)
			});
			visit(BHTree.root, listIDs, {});
			setChildrenOptions(ids);
			genPopulation(1000);
			getProperties(popData, "#node-cond-prop");
			getProperties(popData, "#act-key");

			$("#control-panel").append(playBtn);
			$("#conds").html(listConditions(BHTree.conditions));
			$("#cond-available").addClass('form-control');
			$("#acts").append(listActions(actions));
			$("#act-available").addClass('form-control');

			mouseDown = true;
		};

		var runBHTree = function() {
			var csv, encodedUri, link;
			BHTree.history = [];
			BHTree.time = 0
			generateTimeData(BHTree, 1, 14, 1);
			csv = generateCSV(BHTree.history);
			summary = summarizeTimeData(BHTree.history, ['dead']);
			encodedUri = QKit.Utils.createCSVURI(csv);
			link = document.createElement("a");
			link.setAttribute("href", encodedUri);
			link.setAttribute("download", "bt_data.csv");
			link.setAttribute("target", "_blank");
			link.setAttribute("class", "btn btn-default")
			link.innerHTML = "Get CSV file";
			$("#control-panel").append(link);
		}

		var row = 0;
		var col = 0;
		var generateCSV = function(data) {
			var results = [];
			for (var i = 0; i < data.length; i++) {
				for (var d in data[i]) {
					results.push([]);
					var index = results.length - 1;
					for (var prop in data[i][d]) {
						results[index].push(data[i][d][prop]);
					}
				}
			}
			results.unshift(popProps);
			return results;
		}
		var generateTimeData = function(tree, step, limit, saveInterval) {
			while (tree.time <= limit) {
				var rem = tree.time % saveInterval;
				if (rem == 0) {
					tree.data.map(function(d) {
						return d.time = tree.time
					});
					tree.history.push(jQuery.extend(true, {}, tree.data));
				}
				tree.update();
				tree.time += step;
			}
			return tree.history;
		}

		function animate() {
			requestAnimationFrame(animate);
		}

		function addCondition(conds) {
			var name = $("#node-cond-name").val(),
				ch = $("#node-cond-op").val();
			switch (ch) {
				case "equalTo":
					ch = QKit.BehaviorTree.equalTo;
					break;
				case "notEqualTo":
					ch = QKit.BehaviorTree.notEqualTo;
					break;
				case "gt":
					ch = QKit.BehaviorTree.gt;
					break;
				case "gtEq":
					ch = QKit.BehaviorTree.gtEq;
					break;
				case "lt":
					ch = QKit.BehaviorTree.lt;
					break;
				case "ltEq":
					ch = QKit.BehaviorTree.ltEq;
					break;
				default:
					throw "Not a valid condition checker"
					break;
			}
			conds[name] = {
				key: $("#node-cond-prop").val(),
				value: $("#node-cond-value").val(),
				check: ch,
				data: "default"
			}
			$("#conds").html(listConditions(conditions));
			$("#cond-available").addClass('form-control');
		}

		var addNode = function() {
			var nodeJSON, parent, node = {
				id: $("#node-id").val(),
				type: $("#node-type").val()
			};
			if (node.type === "condition" || node.type === "action") {
				node.condition = conditions[$("#cond-available option:selected").val()]
				if (node.type === "action") {
					//TODO
					node.action = actions[$("#act-available option:selected").val()]
				}
			} else {
				node.children = [];
			}
			nodeJSON = JSON.stringify(node);
			node = QKit.BehaviorTree.fromJSON(nodeJSON);
			var options = {};
			options.id = $("#node-parent option:selected").val();
			options = visit(BHTree.root, findByID, options);
			//options.parent gets assigned

			if (options.nodeFound.type === "condition" || options.nodeFound.type === "action") {
				throw "Cannot create children for leaf type nodes";
			} else {
				options.nodeFound.children = options.nodeFound.children || [];
				options.nodeFound.children.push(node);
			}
			ids = [];
			visit(BHTree.root, listIDs, {});
			setChildrenOptions(ids);
			render("diagram");
		};

		var ids = [];
		var visit = function(node, cb, options) {
			cb(node, options);
			if (node.children !== null) {
				for (var c in node.children) {
					visit(node.children[c], cb, options);
				}
			}
			return options;
		};

		var listIDs = function(node) {
			ids.push(node.id);
			return false;
		};

		var findByID = function(node, options) {
			if (node.id === options.id) {
				console.log(node)
				options.nodeFound = node;
			}
		}

		var listConditions = function(conds) {
			var select = document.createElement("select"),
				option;
			select.id = "cond-available";
			for (c in conds) {
				option = document.createElement("option");
				option.id = "cond-" + c;
				option.innerHTML = c;
				select.appendChild(option);
			}
			return select;
		}

		var listActions = function(acts) {
			var select = document.createElement("select"),
				option;
			select.id = "act-available";
			for (c in acts) {
				option = document.createElement("option");
				option.id = "act-" + c;
				option.innerHTML = c;
				select.appendChild(option);
			}
			return select;
		}



		var getProperties = function(data, container) {
			var props = [];
			for (var prop in data[0]) {
				props.push(prop);
				$(container).append(
					"<option>" + prop + "</option>"
				);
			}

		}

		var setChildrenOptions = function(data) {
			$("#node-parent").html("");
			for (var i = 0; i < data.length; i++) {
				$("#node-parent").append(
					"<option>" + data[i] + "</option>"
				);
			}
		};

		var summarizeTimeData = function(data, keys) {
			var results = [];
			for (var step = 0; step < data.length; step++) {
				results[step] = {};
				for (var d in data[step]) {
					for (var key = 0; key < keys.length; key++) {
						if (data[step][d][keys[key]] == true) {
							results[step][keys[key]] = results[step][keys[key]] + 1 || 0;
						}
					}
				}
			}
			return results;
		}

		function zoom() {
			svgGroup.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
		}

		var zoomListener = d3.behavior.zoom().scaleExtent([0.1, 3]).on("zoom", zoom);

		var render = function(container) {
			d3.select("svg")
				.remove();
			var diagram;
			var margin = {
					top: 20,
					right: 120,
					bottom: 20,
					left: 120
				},
				width = document.getElementById(container).offsetWidth - margin.right - margin.left,
				height = document.getElementById(container).offsetHeight - margin.top - margin.bottom;
			try {
				var tree = d3.layout.tree()
					.size([height, width]);
			} catch (error) {
				throw "requires d3 library";
			}

			var i = 0;

			var diagonal = d3.svg.diagonal()
				.projection(function(d) {
					return [d.y, d.x];
				});

			svg = d3.select("#" + container).append("svg")
				.attr("width", width + margin.right + margin.left)
				.attr("height", height + margin.top + margin.bottom)
				.call(zoomListener);

			svgGroup = svg.append("g")
				.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

			var nodes = tree.nodes(BHTree.root),
				links = tree.links(nodes);

			// Normalize for fixed-depth.
			nodes.forEach(function(d) {
				d.y = d.depth * 180;
			});

			// Declare the nodes…
			var node = svgGroup.selectAll("g.node")
				.data(nodes, function(d) {
					return d.id || (d.id = ++i);
				});

			// Enter the nodes.
			var nodeEnter = node.enter().append("g")
				.attr("class", function(d) {
					return d.type
				})
				.attr("transform", function(d) {
					return "translate(" + d.y + "," + d.x + ")";
				});

			nodeEnter.append("circle")
				.attr("r", 10)


			nodeEnter.append("text")
				.attr("x", function(d) {
					return d.children || d._children ? -13 : 13;
				})
				.attr("dy", ".35em")
				.attr("text-anchor", function(d) {
					return d.children || d._children ? "end" : "start";
				})
				.text(function(d) {
					return d.type + " : " + d.id;
				})
				.style("fill-opacity", 1);

			// Declare the links…
			var link = svgGroup.selectAll("path.link")
				.data(links, function(d) {
					return d.target.id;
				});

			// Enter the links.
			link.enter().insert("path", "g")
				.attr("class", "link")
				.attr("d", diagonal);
		}

		function pan(domNode, direction) {
			var speed = panSpeed;
			if (panTimer) {
				clearTimeout(panTimer);
				translateCoords = d3.transform(svgGroup.attr("transform"));
				if (direction == 'left' || direction == 'right') {
					translateX = direction == 'left' ? translateCoords.translate[0] + speed : translateCoords.translate[0] - speed;
					translateY = translateCoords.translate[1];
				} else if (direction == 'up' || direction == 'down') {
					translateX = translateCoords.translate[0];
					translateY = direction == 'up' ? translateCoords.translate[1] + speed : translateCoords.translate[1] - speed;
				}
				scaleX = translateCoords.scale[0];
				scaleY = translateCoords.scale[1];
				scale = zoomListener.scale();
				svgGroup.transition().attr("transform", "translate(" + translateX + "," + translateY + ")scale(" + scale + ")");
				d3.select(domNode).select('g.node').attr("transform", "translate(" + translateX + "," + translateY + ")");
				zoomListener.scale(zoomListener.scale());
				zoomListener.translate([translateX, translateY]);
				panTimer = setTimeout(function() {
					pan(domNode, speed, direction);
				}, 50);
			}
		}




		init();
	</script>
</body>

</html>
